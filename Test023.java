/* =================================================
■■■ 연산자(Operator) ■■■
- 비트 단위 연산자 (&, | ,^, ~) 
논리연산자랑 다름! &&, ||, !
- 비트 shift 연산 -> 가장 빠름
===================================================*/

public class Test023
{
	public static void main(String[] args)
	{
					  //				            |
		int x = 128;  // 00000000 00000000 00000000 10000000 
		              // 00000000 00000000 00000100 00000000
					  //                        |

		System.out.printf("x << 3 : %d\n", x<<3);
		System.out.printf("x * 8 : %d\n", x*8);
		// 둘다 1024
		// *8 보다 <<를 한 것이 더 빠르게 처리된다.

		System.out.printf("x >> 3 : %d\n", x>>3);
		System.out.printf("x / 8 : %d\n", x/8);
		// 16

		//  >> -> 비트열 이동 시 빈 자리에 양수면 0, 음수면 1  => 부호 유지
		//  >>> -> 비트열 이동 시 빈자리에 무조건 0을 채워넣음

		System.out.printf("x << 24 : %d\n", x<<24);
		//x << 24 : -2147483648  제일 앞에 1이되면 음수가 되고 음수 중에서도 제일 최대값이 됨
		// 10000000 00000000 00000000 00000000
		// |


		System.out.printf("x << 25 : %d\n", x<<25);
		System.out.printf("x << 26 : %d\n", x<<26);
		System.out.printf("x << 31 : %d\n", x<<31);
		// 0 -> 25번째는 다시 맨 맨뒤로감
		// 00000000 000000000 00000001 이지만 0임 값을 발현 못함 32칸 이동해서 100000000되면 128 발현됨
		//                     -------  이만큼은 발현안된다는 것! 내자리인 128이 나오기 전까진 계속 카운트만 하고있음

		System.out.printf("x << 32 : %d\n", x<<32);
		//128


	}
}
/* 실행 결과
x << 3 : 1024
x * 8 : 1024
x >> 3 : 16
x / 8 : 16
x << 24 : -2147483648
x << 25 : 0
x << 26 : 0
x << 31 : 0
x << 32 : 128
계속하려면 아무 키나 누르십시오 . . .
*/
